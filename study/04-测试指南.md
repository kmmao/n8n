# n8n 测试指南

## 测试策略概览

n8n 使用多层测试策略：

| 测试类型 | 工具 | 用途 | 位置 |
|---------|------|------|------|
| 单元测试（后端） | Jest | 测试独立函数、类、服务 | `**/*.test.ts` |
| 单元测试（前端） | Vitest | 测试 Vue 组件、composables | `**/__tests__/**` |
| 工作流测试 | Jest + JSON | 测试节点执行逻辑 | `nodes/**/test/*.test.json` |
| E2E 测试 | Playwright | 测试完整用户流程 | `cypress/` (迁移中) |
| HTTP Mock | nock | Mock 外部 API 调用 | 单元测试中 |

## 运行测试

### 运行所有测试

```bash
# 运行所有包的所有测试
pnpm test

# 只运行受影响的测试（基于 git diff）
pnpm test:affected
```

### 运行特定包的测试

```bash
# 方式 1: 进入包目录
cd packages/cli
pnpm test

# 方式 2: 使用 filter
pnpm --filter @n8n/cli test
```

### 运行特定测试文件

```bash
# 必须在包目录内运行
cd packages/cli
pnpm test src/services/myService.test.ts

# 或使用 Jest 的模式匹配
pnpm test --testPathPattern=myService
```

### Watch 模式

```bash
cd packages/cli
pnpm test --watch
```

在 watch 模式下:
- 按 `p` 过滤文件名
- 按 `t` 过滤测试名
- 按 `u` 更新快照
- 按 `q` 退出

## 后端单元测试 (Jest)

### 基本结构

```typescript
// packages/cli/test/unit/services/workflow.service.test.ts
import { WorkflowService } from '@/services/workflow.service';
import { mock } from 'jest-mock-extended';
import type { WorkflowRepository } from '@/databases/repositories/workflow.repository';

describe('WorkflowService', () => {
  let workflowService: WorkflowService;
  let mockWorkflowRepository: WorkflowRepository;

  beforeEach(() => {
    // 创建 mock 对象
    mockWorkflowRepository = mock<WorkflowRepository>();

    // 创建被测试的服务
    workflowService = new WorkflowService(mockWorkflowRepository);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getWorkflow', () => {
    it('should return workflow when it exists', async () => {
      // Arrange
      const workflowId = '123';
      const expectedWorkflow = { id: workflowId, name: 'Test' };
      mockWorkflowRepository.findById.mockResolvedValue(expectedWorkflow);

      // Act
      const result = await workflowService.getWorkflow(workflowId);

      // Assert
      expect(result).toEqual(expectedWorkflow);
      expect(mockWorkflowRepository.findById).toHaveBeenCalledWith(workflowId);
    });

    it('should throw error when workflow not found', async () => {
      // Arrange
      mockWorkflowRepository.findById.mockResolvedValue(null);

      // Act & Assert
      await expect(workflowService.getWorkflow('999'))
        .rejects
        .toThrow('Workflow not found');
    });
  });
});
```

### Mock HTTP 请求 (nock)

```typescript
import nock from 'nock';

describe('ExternalAPIService', () => {
  beforeEach(() => {
    // 禁止真实 HTTP 请求
    nock.disableNetConnect();
  });

  afterEach(() => {
    nock.cleanAll();
    nock.enableNetConnect();
  });

  it('should fetch data from external API', async () => {
    // Mock HTTP 响应
    nock('https://api.example.com')
      .get('/data')
      .reply(200, { result: 'success' });

    const service = new ExternalAPIService();
    const result = await service.fetchData();

    expect(result.result).toBe('success');
  });

  it('should handle API errors', async () => {
    nock('https://api.example.com')
      .get('/data')
      .reply(500, { error: 'Internal Server Error' });

    const service = new ExternalAPIService();

    await expect(service.fetchData()).rejects.toThrow();
  });
});
```

### 测试依赖注入

```typescript
import { Container } from '@n8n/di';
import { MyService } from '@/services/my.service';
import { MyRepository } from '@/repositories/my.repository';

describe('MyService with DI', () => {
  let container: Container;
  let service: MyService;

  beforeEach(() => {
    container = new Container();
    container.bind(MyRepository).toConstantValue(mock<MyRepository>());
    service = container.get(MyService);
  });

  it('should work with injected dependencies', () => {
    // 测试代码
  });
});
```

## 前端单元测试 (Vitest)

### 测试 Vue 组件

```typescript
// packages/frontend/editor-ui/src/components/__tests__/MyButton.test.ts
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import MyButton from '../MyButton.vue';

describe('MyButton', () => {
  it('renders correctly', () => {
    const wrapper = mount(MyButton, {
      props: {
        label: 'Click me',
      },
    });

    expect(wrapper.text()).toContain('Click me');
  });

  it('emits click event when clicked', async () => {
    const wrapper = mount(MyButton);

    await wrapper.find('button').trigger('click');

    expect(wrapper.emitted('click')).toHaveLength(1);
  });

  it('disables button when disabled prop is true', () => {
    const wrapper = mount(MyButton, {
      props: {
        disabled: true,
      },
    });

    const button = wrapper.find('button');
    expect(button.attributes('disabled')).toBeDefined();
  });
});
```

### 测试 Pinia Store

```typescript
// packages/frontend/@n8n/stores/__tests__/ui.store.test.ts
import { setActivePinia, createPinia } from 'pinia';
import { describe, it, expect, beforeEach } from 'vitest';
import { useUIStore } from '../ui.store';

describe('useUIStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  it('should toggle sidebar', () => {
    const store = useUIStore();

    expect(store.sidebarOpen).toBe(false);

    store.toggleSidebar();
    expect(store.sidebarOpen).toBe(true);

    store.toggleSidebar();
    expect(store.sidebarOpen).toBe(false);
  });

  it('should add notification', () => {
    const store = useUIStore();

    store.addNotification({
      type: 'success',
      message: 'Test message',
    });

    expect(store.notifications).toHaveLength(1);
    expect(store.notifications[0].message).toBe('Test message');
  });
});
```

### 测试 Composables

```typescript
// packages/frontend/@n8n/composables/__tests__/useMyComposable.test.ts
import { describe, it, expect } from 'vitest';
import { ref } from 'vue';
import { useMyComposable } from '../useMyComposable';

describe('useMyComposable', () => {
  it('should compute correctly', () => {
    const input = ref(5);
    const { doubled } = useMyComposable(input);

    expect(doubled.value).toBe(10);

    input.value = 10;
    expect(doubled.value).toBe(20);
  });
});
```

### Mock API 调用

```typescript
import { vi } from 'vitest';

// Mock 整个模块
vi.mock('@n8n/rest-api-client', () => ({
  useRestApi: () => ({
    getWorkflows: vi.fn().mockResolvedValue([
      { id: '1', name: 'Workflow 1' },
    ]),
  }),
}));
```

## 节点工作流测试

### JSON 工作流测试

```json
// packages/nodes-base/nodes/MyNode/test/MyNode.workflow.test.json
{
  "name": "Test MyNode with basic input",
  "nodes": [
    {
      "parameters": {
        "text": "Hello World"
      },
      "name": "My Node",
      "type": "n8n-nodes-base.myNode",
      "typeVersion": 1,
      "position": [250, 300],
      "id": "node-1"
    }
  ],
  "connections": {},
  "pinData": {
    "My Node": [
      {
        "json": {
          "text": "Hello World"
        }
      }
    ]
  }
}
```

### 节点执行测试

```typescript
// packages/nodes-base/nodes/MyNode/test/MyNode.node.test.ts
import { testWorkflows } from '@test/nodes/Helpers';

describe('MyNode', () => {
  testWorkflows(['MyNode.workflow.test.json']);
});
```

这会自动：
1. 加载 JSON 工作流
2. 执行节点
3. 验证输出与 pinData 匹配

## E2E 测试 (Playwright)

### 运行 E2E 测试

```bash
# 开发模式（交互式）
pnpm dev:e2e

# 运行所有 E2E 测试
pnpm test:with:docker

# 查看测试报告
pnpm test:show:report
```

### 编写 E2E 测试

```typescript
// packages/n8n-playwright/tests/workflow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Workflow Editor', () => {
  test('should create new workflow', async ({ page }) => {
    // 访问 n8n
    await page.goto('http://localhost:5678');

    // 点击新建工作流
    await page.click('text=New workflow');

    // 验证工作流画布显示
    await expect(page.locator('.workflow-canvas')).toBeVisible();
  });

  test('should add node to workflow', async ({ page }) => {
    await page.goto('http://localhost:5678');

    // 打开节点面板
    await page.click('[data-test-id="node-creator"]');

    // 搜索节点
    await page.fill('[data-test-id="node-search"]', 'HTTP Request');

    // 添加节点
    await page.click('text=HTTP Request');

    // 验证节点已添加
    await expect(page.locator('.node-item')).toContainText('HTTP Request');
  });
});
```

## 测试覆盖率

### 生成覆盖率报告

```bash
# 设置环境变量
COVERAGE_ENABLED=true pnpm test

# 查看覆盖率
open coverage/index.html
```

### 在 VS Code 中查看覆盖率

1. 安装扩展: **Coverage Gutters**
2. 运行测试生成覆盖率
3. 在 VS Code 中按 `Cmd+Shift+P` → "Coverage Gutters: Display Coverage"

绿色: 已覆盖
红色: 未覆盖

## 测试最佳实践

### ✅ DO

1. **遵循 AAA 模式**
   ```typescript
   it('should do something', () => {
     // Arrange - 准备
     const input = 'test';

     // Act - 执行
     const result = myFunction(input);

     // Assert - 断言
     expect(result).toBe('expected');
   });
   ```

2. **Mock 所有外部依赖**
   - 数据库
   - HTTP 请求
   - 文件系统
   - 时间/日期

3. **测试边界情况**
   - 空值 (null, undefined)
   - 空数组/对象
   - 极大/极小值
   - 错误情况

4. **使用描述性的测试名称**
   ```typescript
   // ❌ Bad
   it('works', () => {});

   // ✅ Good
   it('should return user when valid ID is provided', () => {});
   ```

5. **一个测试只测一件事**
   ```typescript
   // ❌ Bad
   it('should do everything', () => {
     expect(a).toBe(1);
     expect(b).toBe(2);
     expect(c).toBe(3);
   });

   // ✅ Good
   it('should set a to 1', () => {
     expect(a).toBe(1);
   });

   it('should set b to 2', () => {
     expect(b).toBe(2);
   });
   ```

### ❌ DON'T

1. **不要测试实现细节**
   - 测试行为，不是实现
   - 测试公共 API，不是私有方法

2. **不要在测试中使用真实数据库**
   - 使用 mock 或内存数据库

3. **不要在测试间共享状态**
   - 每个测试应该独立
   - 使用 beforeEach 重置状态

4. **不要跳过失败的测试**
   ```typescript
   // ❌ Bad
   it.skip('broken test', () => {});

   // ✅ Good - 修复它！
   it('fixed test', () => {});
   ```

## 调试测试

### Jest/Vitest 调试

在 VS Code 中创建调试配置:

```json
{
  "type": "node",
  "request": "launch",
  "name": "Debug Jest",
  "program": "${workspaceFolder}/node_modules/.bin/jest",
  "args": [
    "--runInBand",
    "--testPathPattern=${fileBasename}"
  ],
  "console": "integratedTerminal",
  "internalConsoleOptions": "neverOpen"
}
```

### Playwright 调试

```bash
# 在 UI 模式下运行
pnpm --filter n8n-playwright exec playwright test --ui

# 使用调试模式
pnpm --filter n8n-playwright exec playwright test --debug
```

## 快照测试

### 更新快照

```bash
# 更新所有快照
pnpm test -u

# 在 watch 模式下按 'u' 更新
pnpm test --watch
# 然后按 'u'
```

### 快照示例

```typescript
it('should render component correctly', () => {
  const wrapper = mount(MyComponent);
  expect(wrapper.html()).toMatchSnapshot();
});
```

## CI 中的测试

项目在 GitHub Actions 中运行测试:

```bash
# 运行 CI 测试（继续失败）
pnpm test:ci

# 只运行前端测试
pnpm test:ci:frontend

# 只运行后端测试
pnpm test:ci:backend
```

## 常见问题

### Q: 如何只运行一个测试？

```typescript
// 使用 .only
it.only('this test will run', () => {});
```

### Q: 如何跳过测试？

```typescript
// 使用 .skip
it.skip('this test will be skipped', () => {});
```

### Q: 测试运行很慢怎么办？

1. 只运行受影响的测试: `pnpm test:affected`
2. 使用 watch 模式
3. 并行运行: `pnpm test --maxWorkers=4`

### Q: Mock 不起作用？

确保 mock 在 import 之前:

```typescript
// ✅ Correct
vi.mock('./module');
import { something } from './module';

// ❌ Wrong
import { something } from './module';
vi.mock('./module');
```

## 下一步

- 📖 查看实际测试示例: `packages/nodes-base/nodes/**/__tests__`
- 📖 阅读 `05-常用命令.md` 快速查找测试命令
- 📖 参考官方文档: [Jest](https://jestjs.io/) | [Vitest](https://vitest.dev/) | [Playwright](https://playwright.dev/)
